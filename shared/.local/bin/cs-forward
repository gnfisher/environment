#!/usr/bin/env bash
set -euo pipefail

SCRIPT_NAME="$(basename "$0")"
CODESPACE=""
DEVCONTAINER_PATH=""
DRY_RUN=false
PORTS_OVERRIDE=""
RUN_IN_BACKGROUND=true
MODE="forward"
MAX_PORTS=10  # gh CLI has issues with too many ports

STATE_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/cs-forward"
PID_FILE="${STATE_DIR}/forward.pid"
INFO_FILE="${STATE_DIR}/forward.info"
LOG_FILE="${STATE_DIR}/forward.log"

# Priority ports to forward first (common dev ports)
PRIORITY_PORTS="80 2206 2208 2209 3000 3003 3306 4000 5432 8080 8000 9000"

usage() {
    cat <<EOF
cs-forward - Forward ports from a GitHub Codespace devcontainer

Usage: $SCRIPT_NAME [command] [OPTIONS]

Commands:
  forward               Forward ports (default)
  stop                  Stop active port forwarding
  status                Show current forwarding status

Options:
  -c, --codespace <name>   Codespace name (if omitted, auto-select when possible)
  --devcontainer <path>    devcontainer.json path in codespace
  --ports <list>           Override ports (comma/space-separated, supports ranges like 3000-3002)
  --max-ports <n>          Maximum ports to forward (default: $MAX_PORTS, gh CLI has issues with many)
  --dry-run                Print what would happen without forwarding
  --foreground             Run in foreground (blocks until stopped)
  -h, --help               Show this help message

Examples:
  $SCRIPT_NAME --codespace my-cs
  $SCRIPT_NAME -c my-cs --dry-run
  $SCRIPT_NAME stop
  $SCRIPT_NAME status
  $SCRIPT_NAME -c my-cs --ports 3000,8080
  $SCRIPT_NAME --ports 3000-3002 --dry-run
  $SCRIPT_NAME --max-ports 5
EOF
}

log() { echo "==> $*"; }
error() { echo "Error: $*" >&2; }

require_cmd() {
    if ! command -v "$1" >/dev/null 2>&1; then
        error "Required command not found: $1"
        exit 1
    fi
}

ensure_state_dir() {
    mkdir -p "$STATE_DIR"
}

read_state() {
    if [[ -f "$INFO_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$INFO_FILE"
    fi
}

write_state() {
    local pids="$1"
    local codespace="$2"
    local ports="$3"
    ensure_state_dir
    cat <<EOF > "$INFO_FILE"
codespace="$codespace"
ports="$ports"
pids="$pids"
log_file="$LOG_FILE"
EOF
    echo "$pids" > "$PID_FILE"
}

cleanup_state() {
    rm -f "$PID_FILE" "$INFO_FILE"
}

status_forwarding() {
    if [[ ! -f "$PID_FILE" ]]; then
        echo "No active port forwarding."
        return 0
    fi
    local pids_str
    pids_str=$(cat "$PID_FILE" 2>/dev/null || true)
    if [[ -z "$pids_str" ]]; then
        echo "No active port forwarding."
        cleanup_state
        return 0
    fi
    
    # Check if any PID is still running
    local running_pids=()
    for pid in $pids_str; do
        if kill -0 "$pid" 2>/dev/null; then
            running_pids+=("$pid")
        fi
    done
    
    if [[ ${#running_pids[@]} -gt 0 ]]; then
        read_state
        echo "Forwarding is running."
        echo "  PIDs:      ${running_pids[*]}"
        if [[ -n "${codespace:-}" ]]; then
            echo "  Codespace: $codespace"
        fi
        if [[ -n "${ports:-}" ]]; then
            echo "  Ports:     $ports"
        fi
        if [[ -n "${log_file:-}" ]]; then
            echo "  Log:       $log_file"
        fi
        return 0
    fi
    echo "No active port forwarding."
    cleanup_state
    return 0
}

stop_forwarding() {
    if [[ ! -f "$PID_FILE" ]]; then
        echo "No forwarding process found."
        return 0
    fi
    local pids_str
    pids_str=$(cat "$PID_FILE" 2>/dev/null || true)
    if [[ -z "$pids_str" ]]; then
        echo "No forwarding process found."
        cleanup_state
        return 0
    fi
    
    local any_running=false
    for pid in $pids_str; do
        if kill -0 "$pid" 2>/dev/null; then
            any_running=true
            break
        fi
    done
    
    if [[ "$any_running" == "false" ]]; then
        echo "Forwarding processes not running."
        cleanup_state
        return 0
    fi
    
    log "Stopping forwarding processes..."
    for pid in $pids_str; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
    done
    
    # Wait for all to stop
    local attempts=0
    while true; do
        local still_running=false
        for pid in $pids_str; do
            if kill -0 "$pid" 2>/dev/null; then
                still_running=true
                break
            fi
        done
        if [[ "$still_running" == "false" ]]; then
            break
        fi
        attempts=$((attempts + 1))
        if [[ $attempts -ge 10 ]]; then
            error "Unable to stop all forwarding processes"
            return 1
        fi
        sleep 1
    done
    cleanup_state
    echo "Forwarding stopped."
}

detect_python() {
    if command -v python3 >/dev/null 2>&1; then
        echo "python3"
        return 0
    fi
    if command -v python >/dev/null 2>&1; then
        echo "python"
        return 0
    fi
    error "python3 is required to parse devcontainer.json"
    exit 1
}

# Check if a port is in use locally (listening)
is_local_port_in_use() {
    local port="$1"
    lsof -iTCP:"$port" -sTCP:LISTEN -P -n >/dev/null 2>&1
}

# Get list of ports actually listening in the codespace
get_remote_listening_ports() {
    # Returns space-separated list of listening ports
    # Use netstat as it's more portable and has simpler output
    remote_exec "netstat -tln 2>/dev/null | grep LISTEN | sed 's/.*:\\([0-9]*\\) .*/\\1/' | sort -n -u | tr '\\n' ' '" 2>/dev/null || true
}

# Filter ports to only those listening remotely; error on local conflicts
filter_available_ports() {
    local requested_ports="$1"
    local remote_listening="$2"
    local available=()
    local skipped_remote=()
    local conflicts=()

    for port in $requested_ports; do
        # Check if port is listening in codespace
        if ! echo "$remote_listening" | grep -qw "$port"; then
            skipped_remote+=("$port")
            continue
        fi
        # Check if port is in use locally - this is an error
        if is_local_port_in_use "$port"; then
            conflicts+=("$port")
            continue
        fi
        available+=("$port")
    done

    # Error if any local port conflicts
    if [[ ${#conflicts[@]} -gt 0 ]]; then
        error "Local port conflict: ${conflicts[*]}"
        error "Free these ports or use --ports to specify different ones"
        exit 1
    fi

    # Report skipped ports
    if [[ ${#skipped_remote[@]} -gt 0 ]]; then
        echo "Skipping (not listening in codespace): ${skipped_remote[*]}" >&2
    fi

    echo "${available[*]}"
}

resolve_codespace() {
    local codespaces
    mapfile -t codespaces < <(gh codespace list --json name --jq '.[].name' 2>/dev/null || true)
    if [[ ${#codespaces[@]} -eq 0 ]]; then
        error "No codespaces found (use --codespace to specify)"
        exit 1
    fi
    if [[ ${#codespaces[@]} -eq 1 ]]; then
        CODESPACE="${codespaces[0]}"
        return 0
    fi
    error "Multiple codespaces found. Use --codespace to specify one:"
    for cs in "${codespaces[@]}"; do
        echo "  - $cs" >&2
    done
    exit 1
}

resolve_repo_name() {
    local repo
    # API returns repository as "owner/repo" string, extract just the repo name
    repo=$(gh codespace list --json name,repository \
        --jq ".[] | select(.name==\"${CODESPACE}\") | .repository" 2>/dev/null | head -1)
    if [[ -z "$repo" ]]; then
        error "Unable to determine repository for codespace '$CODESPACE'"
        exit 1
    fi
    # Extract repo name from "owner/repo" format
    echo "${repo##*/}"
}

remote_exec() {
    gh codespace ssh -c "$CODESPACE" -- "$1"
}

remote_file_exists() {
    local path="$1"
    remote_exec "test -f '$path'"
}

resolve_devcontainer_path() {
    local repo="$1"
    local repo_dir="/workspaces/$repo"

    if [[ -n "$DEVCONTAINER_PATH" ]]; then
        if [[ "$DEVCONTAINER_PATH" != /* ]]; then
            DEVCONTAINER_PATH="${repo_dir}/${DEVCONTAINER_PATH}"
        fi
        echo "$DEVCONTAINER_PATH"
        return 0
    fi

    if remote_file_exists "${repo_dir}/.devcontainer/devcontainer.json"; then
        echo "${repo_dir}/.devcontainer/devcontainer.json"
        return 0
    fi

    if remote_file_exists "${repo_dir}/.devcontainer.json"; then
        echo "${repo_dir}/.devcontainer.json"
        return 0
    fi

    local found
    found=$(remote_exec "find /workspaces -maxdepth 4 \\( -name devcontainer.json -o -name .devcontainer.json \\) 2>/dev/null | head -1" || true)
    if [[ -n "$found" ]]; then
        echo "$found"
        return 0
    fi

    error "devcontainer.json not found in codespace"
    exit 1
}

parse_ports_override() {
    local raw="$1"
    raw="${raw//,/ }"
    local ports=()
    local token
    for token in $raw; do
        if [[ "$token" =~ ^[0-9]+$ ]]; then
            ports+=("$token")
        elif [[ "$token" =~ ^([0-9]+)-([0-9]+)$ ]]; then
            local start="${BASH_REMATCH[1]}"
            local end="${BASH_REMATCH[2]}"
            if [[ "$start" -le "$end" ]]; then
                local p
                for p in $(seq "$start" "$end"); do
                    ports+=("$p")
                done
            fi
        fi
    done

    if [[ ${#ports[@]} -eq 0 ]]; then
        echo ""
        return 0
    fi

    printf '%s\n' "${ports[@]}" | sort -n -u | tr '\n' ' ' | sed 's/ $//'
}

parse_ports_from_json() {
    local json="$1"
    local python_bin
    python_bin=$(detect_python)
    local script
    script=$(cat <<'PY'
import json
import sys

text = sys.stdin.read()

def strip_jsonc(src: str) -> str:
    out = []
    i = 0
    in_str = False
    escape = False
    length = len(src)
    while i < length:
        ch = src[i]
        if in_str:
            out.append(ch)
            if escape:
                escape = False
            elif ch == "\\":
                escape = True
            elif ch == '"':
                in_str = False
            i += 1
            continue
        if ch == '"':
            in_str = True
            out.append(ch)
            i += 1
            continue
        if ch == "/" and i + 1 < length:
            nxt = src[i + 1]
            if nxt == "/":
                i += 2
                while i < length and src[i] not in "\n\r":
                    i += 1
                continue
            if nxt == "*":
                i += 2
                while i + 1 < length and not (src[i] == "*" and src[i + 1] == "/"):
                    i += 1
                i += 2
                continue
        out.append(ch)
        i += 1
    return "".join(out)

def add_port_value(value, target):
    if isinstance(value, int):
        target.add(value)
        return
    if isinstance(value, str):
        if value.isdigit():
            target.add(int(value))
            return
        if "-" in value:
            parts = value.split("-", 1)
            if len(parts) == 2 and parts[0].isdigit() and parts[1].isdigit():
                start = int(parts[0])
                end = int(parts[1])
                if start <= end:
                    for p in range(start, end + 1):
                        target.add(p)

try:
    cleaned = strip_jsonc(text)
    data = json.loads(cleaned)
except Exception as exc:
    print(f"Failed to parse devcontainer.json: {exc}", file=sys.stderr)
    sys.exit(1)

ports = set()

for key in ("forwardPorts", "appPort"):
    if key in data:
        value = data[key]
        if isinstance(value, list):
            for item in value:
                add_port_value(item, ports)
        else:
            add_port_value(value, ports)

ports_attributes = data.get("portsAttributes", {})
if isinstance(ports_attributes, dict):
    for port_key in ports_attributes.keys():
        add_port_value(str(port_key), ports)

print(" ".join(str(p) for p in sorted(ports)))
PY
)
    printf '%s' "$json" | "$python_bin" -c "$script"
}

if [[ $# -gt 0 ]]; then
    case "$1" in
        forward|stop|status)
            MODE="$1"
            shift
            ;;
    esac
fi

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -c|--codespace)
            CODESPACE="${2:-}"
            shift 2
            ;;
        --codespace=*)
            CODESPACE="${1#--codespace=}"
            shift
            ;;
        --devcontainer)
            DEVCONTAINER_PATH="${2:-}"
            shift 2
            ;;
        --devcontainer=*)
            DEVCONTAINER_PATH="${1#--devcontainer=}"
            shift
            ;;
        --ports)
            PORTS_OVERRIDE="${2:-}"
            shift 2
            ;;
        --ports=*)
            PORTS_OVERRIDE="${1#--ports=}"
            shift
            ;;
        --max-ports)
            MAX_PORTS="${2:-}"
            shift 2
            ;;
        --max-ports=*)
            MAX_PORTS="${1#--max-ports=}"
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --foreground)
            RUN_IN_BACKGROUND=false
            shift
            ;;
        *)
            error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

if [[ "$MODE" == "stop" ]]; then
    stop_forwarding
    exit $?
fi

if [[ "$MODE" == "status" ]]; then
    status_forwarding
    exit $?
fi

if [[ -z "$PORTS_OVERRIDE" || "$DRY_RUN" == "false" ]]; then
    require_cmd gh
fi

if [[ -z "$CODESPACE" ]]; then
    if [[ -n "$PORTS_OVERRIDE" && "$DRY_RUN" == "true" ]]; then
        CODESPACE="(not specified)"
    else
        resolve_codespace
    fi
fi

ports_list=""
devcontainer=""

if [[ -n "$PORTS_OVERRIDE" ]]; then
    ports_list=$(parse_ports_override "$PORTS_OVERRIDE")
    if [[ -z "$ports_list" ]]; then
        error "No valid ports found in --ports"
        exit 1
    fi
else
    log "Resolving devcontainer.json in codespace '$CODESPACE'..."
    repo_name=$(resolve_repo_name)
    devcontainer=$(resolve_devcontainer_path "$repo_name")
    log "Using devcontainer: $devcontainer"
    devcontainer_json=$(remote_exec "cat '$devcontainer'")
    ports_list=$(parse_ports_from_json "$devcontainer_json")
    if [[ -z "$ports_list" ]]; then
        error "No ports found in devcontainer.json"
        exit 1
    fi
fi

# Filter to only available ports (listening remotely, available locally)
if [[ "$DRY_RUN" == "false" ]]; then
    log "Checking which ports are available..."
    remote_listening=$(get_remote_listening_ports)
    ports_list=$(filter_available_ports "$ports_list" "$remote_listening")
fi

read -r -a ports <<< "$ports_list"
if [[ ${#ports[@]} -eq 0 ]]; then
    error "No ports to forward (all filtered out)"
    exit 1
fi

# Sort ports: priority ports first, then rest numerically
# This ensures common dev ports are forwarded even if we hit the limit
sorted_ports=()
for pport in $PRIORITY_PORTS; do
    for port in "${ports[@]}"; do
        if [[ "$port" == "$pport" ]]; then
            sorted_ports+=("$port")
            break
        fi
    done
done
for port in "${ports[@]}"; do
    is_priority=false
    for pport in $PRIORITY_PORTS; do
        if [[ "$port" == "$pport" ]]; then
            is_priority=true
            break
        fi
    done
    if [[ "$is_priority" == "false" ]]; then
        sorted_ports+=("$port")
    fi
done
ports=("${sorted_ports[@]}")

# Limit number of ports (gh CLI has issues with too many)
if [[ ${#ports[@]} -gt $MAX_PORTS ]]; then
    echo "Limiting to $MAX_PORTS ports (use --max-ports to change)"
    ports=("${ports[@]:0:$MAX_PORTS}")
fi

forward_args=()
for port in "${ports[@]}"; do
    forward_args+=("${port}:${port}")
done

echo "Codespace:   $CODESPACE"
if [[ -n "$devcontainer" ]]; then
    echo "Devcontainer: $devcontainer"
fi
echo "Ports:       ${ports[*]}"
echo

if [[ "$DRY_RUN" == "true" ]]; then
    echo "[DRY RUN] gh codespace ports forward -c $CODESPACE ${forward_args[*]}"
    exit 0
fi

log "Forwarding ports..."
if [[ "$RUN_IN_BACKGROUND" == "true" ]]; then
    ensure_state_dir
    if [[ -f "$PID_FILE" ]]; then
        # Check if any processes are still running
        existing_pids=$(cat "$PID_FILE" 2>/dev/null || true)
        for pid in $existing_pids; do
            if kill -0 "$pid" 2>/dev/null; then
                error "Forwarding already running. Use '$SCRIPT_NAME stop' first."
                exit 1
            fi
        done
        cleanup_state
    fi
    
    # Start one gh process per port to avoid concurrent map writes bug
    pids=()
    : > "$LOG_FILE"  # Clear log file
    for port in "${ports[@]}"; do
        nohup gh codespace ports forward -c "$CODESPACE" "${port}:${port}" >> "$LOG_FILE" 2>&1 &
        pids+=($!)
        sleep 0.5  # Small delay between starts
    done
    
    write_state "${pids[*]}" "$CODESPACE" "${ports[*]}"
    echo "Forwarding started (${#pids[@]} processes)."
    echo "Use '$SCRIPT_NAME stop' to stop forwarding."
else
    # Foreground mode - still need to start separately but wait for ctrl-c
    trap 'echo "Stopping..."; for p in "${pids[@]}"; do kill $p 2>/dev/null; done; exit 0' INT TERM
    pids=()
    for port in "${ports[@]}"; do
        gh codespace ports forward -c "$CODESPACE" "${port}:${port}" &
        pids+=($!)
        sleep 0.5
    done
    echo "Forwarding ${#pids[@]} ports. Press Ctrl-C to stop."
    wait
fi
