#!/usr/bin/env bash
#
# Unified theme switcher for light/dark mode
# Switches: Ghostty, Neovim, Tmux, FZF, Copilot CLI
# OpenCode auto-follows system appearance.
# Color scheme: mono (light: Terminal Basic + mono, dark: mono-dark + mono)
#
# Usage:
#   theme light    - Switch to light mode
#   theme dark     - Switch to dark mode
#   theme toggle   - Toggle between light and dark
#   theme status   - Show current theme
#
# Can be triggered from Raycast, CLI, or macOS appearance change

set -euo pipefail

THEME_STATE_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/theme-mode"

# Ensure state directory exists
mkdir -p "$(dirname "$THEME_STATE_FILE")"

# Resolve symlinks to get the real file path (sed -i doesn't work on symlinks)
resolve_path() {
    local path="$1"
    if [[ -L "$path" ]]; then
        local target
        target=$(readlink "$path")
        if [[ "$target" = /* ]]; then
            echo "$target"
        else
            local base_dir
            base_dir=$(cd -P "$(dirname "$path")" && pwd)
            local target_dir
            target_dir=$(cd -P "$(dirname "$base_dir/$target")" && pwd)
            echo "$target_dir/$(basename "$target")"
        fi
    else
        echo "$path"
    fi
}

get_current_theme() {
    if [[ -f "$THEME_STATE_FILE" ]]; then
        cat "$THEME_STATE_FILE"
    else
        echo "dark"
    fi
}

set_theme_state() {
    echo "$1" > "$THEME_STATE_FILE"
}

# Switch Ghostty theme (auto-reloads on config change)
switch_ghostty() {
    local mode="$1"
    local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/ghostty/config"

    if [[ ! -f "$config_file" ]]; then
        return
    fi

    config_file=$(resolve_path "$config_file")

    local theme_value
    if [[ "$mode" == "light" ]]; then
        theme_value="Terminal Basic"
    else
        theme_value="mono-dark"
    fi

    sed -i '' "s/^theme = .*/theme = $theme_value/" "$config_file"
}

# Switch Neovim theme in all running instances
switch_neovim() {
    local mode="$1"
    
    # Find all Neovim server sockets
    local nvim_sockets=()
    
    # Check common socket locations
    if [[ -d "${XDG_RUNTIME_DIR:-/tmp}" ]]; then
        while IFS= read -r -d '' socket; do
            nvim_sockets+=("$socket")
        done < <(find "${XDG_RUNTIME_DIR:-/tmp}" -name 'nvim.*' -type s 2>/dev/null | tr '\n' '\0')
    fi
    
    # Also check /tmp for nvim sockets
    while IFS= read -r -d '' socket; do
        nvim_sockets+=("$socket")
    done < <(find /tmp -name 'nvim*' -type s 2>/dev/null | tr '\n' '\0')
    
    local bg_mode scheme
    if [[ "$mode" == "light" ]]; then
        bg_mode="light"
    else
        bg_mode="dark"
    fi
    scheme="mono"
    
    # Send commands to all running Neovim instances
    # Set background first, then colorscheme re-applies with new palette
    for socket in "${nvim_sockets[@]}"; do
        if [[ -S "$socket" ]]; then
            nvim --server "$socket" --remote-send "<Cmd>set background=$bg_mode<CR><Cmd>colorscheme $scheme<CR>" 2>/dev/null || true
        fi
    done
}

# Switch Tmux theme (matches layout from .tmux.conf)
switch_tmux() {
    local mode="$1"

    if ! command -v tmux &>/dev/null || ! tmux list-sessions &>/dev/null; then
        return
    fi

    if [[ "$mode" == "light" ]]; then
        # Mono Light - transparent bg, minimal
        tmux set -g status-style "bg=default,fg=#777777"
        tmux set -g status-left "#[fg=#222222,bold]  #S #[default]"
        tmux set -g status-right "#[fg=#777777]󰒋 #H "
        tmux set -g window-status-format "#[bg=#eeeeee,fg=#777777] #I #[bg=default,fg=#777777] #W "
        tmux set -g window-status-current-format "#[bg=#222222,fg=#ffffff,bold] #I #[bg=default,fg=#222222,bold] #W "
        tmux set -g pane-border-style "fg=#cccccc"
        tmux set -g pane-active-border-style "fg=#222222"
        tmux set -g message-style "bg=#eeeeee,fg=#222222"
        tmux set -g message-command-style "bg=#eeeeee,fg=#222222"
        tmux set -g mode-style "bg=#f5d87a,fg=#222222"
    else
        # Mono Dark - transparent bg, minimal
        tmux set -g status-style "bg=default,fg=#777777"
        tmux set -g status-left "#[fg=#d4d4d4,bold]  #S #[default]"
        tmux set -g status-right "#[fg=#777777]󰒋 #H "
        tmux set -g window-status-format "#[bg=#2d2d2d,fg=#606060] #I #[bg=default,fg=#606060] #W "
        tmux set -g window-status-current-format "#[bg=#d4d4d4,fg=#191919,bold] #I #[bg=default,fg=#d4d4d4,bold] #W "
        tmux set -g pane-border-style "fg=#3a3a3a"
        tmux set -g pane-active-border-style "fg=#d4d4d4"
        tmux set -g message-style "bg=#2d2d2d,fg=#d4d4d4"
        tmux set -g message-command-style "bg=#2d2d2d,fg=#d4d4d4"
        tmux set -g mode-style "bg=#504000,fg=#d4d4d4"
    fi
}

# Update FZF colors via environment variable
switch_fzf() {
    local mode="$1"
    local fish_theme_file="${XDG_CONFIG_HOME:-$HOME/.config}/fish/conf.d/fzf-theme.fish"
    
    if [[ "$mode" == "light" ]]; then
        # Mono light - grayscale FZF
        local fzf_opts="--color=bg+:#eeeeee,bg:#ffffff,spinner:#999999,hl:#cc0000 \
--color=fg:#222222,header:#444444,info:#999999,pointer:#222222 \
--color=marker:#222222,fg+:#222222,prompt:#555555,hl+:#cc0000 \
--color=selected-bg:#e0e0e0 \
--color=border:#cccccc,label:#222222"
    else
        # Mono dark - grayscale FZF
        local fzf_opts="--color=bg+:#2d2d2d,bg:#191919,spinner:#777777,hl:#ff8787 \
--color=fg:#d4d4d4,header:#aaaaaa,info:#777777,pointer:#d4d4d4 \
--color=marker:#d4d4d4,fg+:#d4d4d4,prompt:#999999,hl+:#ff8787 \
--color=selected-bg:#3a3a3a \
--color=border:#3a3a3a,label:#d4d4d4"
    fi
    
    # Update fish config file (resolve symlink first)
    if [[ -e "$fish_theme_file" ]]; then
        fish_theme_file=$(resolve_path "$fish_theme_file")
        cat > "$fish_theme_file" << EOF
# FZF theme - auto-generated by theme switcher
# Current mode: $mode
status is-interactive; or return

set -Ux FZF_DEFAULT_OPTS "$fzf_opts"
EOF
    fi
    
    # Export for current shell session
    export FZF_DEFAULT_OPTS="$fzf_opts"
}

# Switch Copilot CLI theme
# Our light Ghostty palette inverts ANSI black/white, so Copilot's
# "ANSI Dark" theme (whiteBright text) is actually readable on light bg.
switch_copilot() {
    local mode="$1"
    local config_file="$HOME/.copilot/theme-config"

    if [[ ! -f "$config_file" ]]; then
        return
    fi

    local copilot_theme="dark"
    printf '{\n  "preference": "%s"\n}\n' "$copilot_theme" > "$config_file"
}

# Detect macOS appearance
detect_macos_appearance() {
    if command -v defaults &>/dev/null; then
        local appearance
        appearance=$(defaults read -g AppleInterfaceStyle 2>/dev/null || echo "Light")
        if [[ "$appearance" == "Dark" ]]; then
            echo "dark"
        else
            echo "light"
        fi
    else
        echo "dark"
    fi
}

switch_all() {
    local mode="$1"
    
    echo "Switching to $mode mode..."
    
    switch_ghostty "$mode"
    switch_neovim "$mode"
    switch_tmux "$mode"
    switch_fzf "$mode"
    switch_copilot "$mode"
    
    set_theme_state "$mode"
    
    echo "Done! Theme set to $mode"
}

case "${1:-status}" in
    light)
        switch_all "light"
        ;;
    dark)
        switch_all "dark"
        ;;
    toggle)
        current=$(get_current_theme)
        if [[ "$current" == "light" ]]; then
            switch_all "dark"
        else
            switch_all "light"
        fi
        ;;
    sync)
        # Sync with macOS appearance
        mode=$(detect_macos_appearance)
        switch_all "$mode"
        ;;
    status)
        current=$(get_current_theme)
        echo "Current theme: $current"
        ;;
    *)
        echo "Usage: theme [light|dark|toggle|sync|status]"
        exit 1
        ;;
esac
