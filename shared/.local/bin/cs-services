#!/usr/bin/env bash
set -euo pipefail

# Service definitions
declare -A SERVICE_DIRS=(
    [github]="/workspaces/github"
    [sweagentd]="/workspaces/sweagentd"
    [capi]="/workspaces/copilot-api"
    [mission-control]="/workspaces/copilot-mission-control"
)

WORKTREE_BASE="/workspaces/worktrees"
STATE_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/cs-services"
STATE_FILE="${STATE_DIR}/state.env"

show_help() {
    cat << 'EOF'
cs-services - Unified service management for GitHub Codespaces

Usage: cs-services <command> [service]

Commands:
  status              Show status of all services
  start <service>     Start a specific service (prompts for worktree if available)
  stop <service|all>  Stop a service, or "all" to stop all services
  restart <service>   Restart a specific service (stop then start)
  logs <service>      Tail logs for a service

Services:
  github              Main GitHub monolith
  sweagentd           SWE Agent daemon
  capi                Copilot API
  mission-control     Copilot Mission Control

Options:
  -h, --help          Show this help message
  --worktree <name>   Use a specific worktree (default: main)
  --background        Start service in background when supported

Examples:
  cs-services status
  cs-services start github --worktree feature-branch
  cs-services logs sweagentd
  cs-services restart capi --worktree my-branch
EOF
}

# Get current git branch for a directory
get_branch() {
    local dir="$1"
    if [[ -d "$dir/.git" ]] || [[ -f "$dir/.git" ]]; then
        git -C "$dir" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown"
    else
        echo "N/A"
    fi
}

ensure_state_dir() {
    mkdir -p "$STATE_DIR"
}

state_key() {
    echo "$1" | tr '-' '_'
}

read_state() {
    if [[ -f "$STATE_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$STATE_FILE"
    fi
}

write_state() {
    ensure_state_dir
    {
        for service in github sweagentd capi mission-control; do
            local key var val
            key=$(state_key "$service")
            var="CS_DIR_${key}"
            eval "val=\${$var:-}"
            if [[ -n "$val" ]]; then
                printf '%s=%q\n' "$var" "$val"
            fi
        done
    } > "$STATE_FILE"
}

get_state_dir() {
    local key var
    key=$(state_key "$1")
    var="CS_DIR_${key}"
    eval "echo \"\${$var:-}\""
}

set_state_dir() {
    local key var
    key=$(state_key "$1")
    var="CS_DIR_${key}"
    eval "$var=\"$2\""
    write_state
}

repo_for_service() {
    local service="$1"
    case "$service" in
        github|sweagentd)
            echo "$service"
            ;;
        capi)
            echo "copilot-api"
            ;;
        mission-control)
            echo "copilot-mission-control"
            ;;
        *)
            echo "$service"
            ;;
    esac
}

list_worktrees() {
    local repo="$1"
    local wt_dir="${WORKTREE_BASE}/${repo}"
    if [[ -d "$wt_dir" ]]; then
        for dir in "$wt_dir"/*; do
            [[ -d "$dir" ]] && basename "$dir"
        done
    fi
}

prompt_for_worktree() {
    local repo="$1"
    local worktrees=()
    local wt

    while IFS= read -r wt; do
        worktrees+=("$wt")
    done < <(list_worktrees "$repo")

    if [[ ${#worktrees[@]} -eq 0 ]]; then
        echo ""
        return 0
    fi

    if [[ ! -t 0 ]]; then
        echo ""
        return 0
    fi

    echo "Available worktrees for $repo:"
    echo "  main"
    for wt in "${worktrees[@]}"; do
        echo "  $wt"
    done
    read -rp "Worktree (blank for main): " selection
    if [[ -z "$selection" || "$selection" == "main" ]]; then
        echo ""
        return 0
    fi
    for wt in "${worktrees[@]}"; do
        if [[ "$wt" == "$selection" ]]; then
            echo "$selection"
            return 0
        fi
    done
    echo "Error: Worktree '$selection' not found for $repo" >&2
    exit 1
}

resolve_service_dir() {
    local service="$1"
    local worktree="$2"
    local mode="$3"
    local main_dir="${SERVICE_DIRS[$service]}"
    local repo
    repo=$(repo_for_service "$service")

    if [[ -n "$worktree" ]]; then
        if [[ "$worktree" == "main" ]]; then
            echo "$main_dir"
            return 0
        fi
        local wt_path="${WORKTREE_BASE}/${repo}/${worktree}"
        if [[ ! -d "$wt_path" ]]; then
            echo "Error: Worktree '$worktree' not found at ${wt_path}" >&2
            exit 1
        fi
        echo "$wt_path"
        return 0
    fi

    if [[ "$mode" == "state" ]]; then
        local state_dir
        state_dir=$(get_state_dir "$service")
        if [[ -n "$state_dir" && -d "$state_dir" ]]; then
            echo "$state_dir"
            return 0
        fi
    fi

    if [[ "$mode" == "prompt" ]]; then
        local selection
        selection=$(prompt_for_worktree "$repo")
        if [[ -n "$selection" ]]; then
            local wt_path="${WORKTREE_BASE}/${repo}/${selection}"
            if [[ ! -d "$wt_path" ]]; then
                echo "Error: Worktree '$selection' not found at ${wt_path}" >&2
                exit 1
            fi
            echo "$wt_path"
            return 0
        fi
    fi

    echo "$main_dir"
}

# Check if service directory exists
service_exists() {
    local service="$1"
    local dir="${SERVICE_DIRS[$service]:-}"
    [[ -n "$dir" && -d "$dir" ]]
}

# Validate service name
validate_service() {
    local service="$1"
    if [[ -z "${SERVICE_DIRS[$service]:-}" ]]; then
        echo "Error: Unknown service '$service'" >&2
        echo "Valid services: ${!SERVICE_DIRS[*]}" >&2
        exit 1
    fi
    if ! service_exists "$service"; then
        echo "Error: Service '$service' directory not found (${SERVICE_DIRS[$service]})" >&2
        exit 1
    fi
}

# Check if service is running using service-specific methods
is_service_running() {
    local service="$1"
    case "$service" in
        github)
            # Check for overmind socket
            [[ -S "/tmp/overmind-github.sock" ]] && return 0
            ;;
        sweagentd)
            [[ -S "/tmp/overmind-sweagentd.sock" ]] && return 0
            ;;
        capi)
            # Check for overmind socket or pidfile
            [[ -S "/tmp/overmind-capi.sock" ]] && return 0
            local dir="${SERVICE_DIRS[$service]}"
            [[ -f "$dir/tmp/pids/server.pid" ]] && kill -0 "$(cat "$dir/tmp/pids/server.pid")" 2>/dev/null && return 0
            ;;
        mission-control)
            local dir="${SERVICE_DIRS[$service]}"
            [[ -f "$dir/tmp/pids/server.pid" ]] && kill -0 "$(cat "$dir/tmp/pids/server.pid")" 2>/dev/null && return 0
            ;;
    esac
    return 1
}

# Check service status (returns UP or DOWN)
get_service_status() {
    local service="$1"
    if is_service_running "$service"; then
        echo "UP"
    else
        echo "DOWN"
    fi
}

# Show status for all services
cmd_status() {
    read_state
    printf "%-16s %-8s %-20s\n" "SERVICE" "STATUS" "BRANCH"
    printf "%-16s %-8s %-20s\n" "-------" "------" "------"

    for service in github sweagentd capi mission-control; do
        local dir="${SERVICE_DIRS[$service]}"
        local status branch
        local active_dir="$dir"

        if [[ ! -d "$dir" ]]; then
            printf "%-16s %-8s %-20s\n" "$service" "N/A" "(not installed)"
            continue
        fi

        local state_dir
        state_dir=$(get_state_dir "$service")
        if [[ -n "$state_dir" && -d "$state_dir" ]]; then
            active_dir="$state_dir"
        fi

        status=$(get_service_status "$service")
        branch=$(get_branch "$active_dir")

        printf "%-16s %-8s %-20s\n" "$service" "$status" "$branch"
    done
}

# Start a service
cmd_start() {
    local service="$1"
    shift
    local worktree=""
    local background=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --worktree)
                worktree="${2:-}"
                shift 2
                ;;
            --worktree=*)
                worktree="${1#--worktree=}"
                shift
                ;;
            --background)
                background=true
                shift
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
        esac
    done
    validate_service "$service"

    local dir
    dir=$(resolve_service_dir "$service" "$worktree" "prompt")

    echo "Starting $service (dir: $dir)..."
    cd "$dir"

    case "$service" in
        github)
            if [[ -x "script/dx/server-start" ]]; then
                if [[ "$background" == "true" ]]; then
                    script/dx/server-start --ui >/dev/null 2>&1 &
                else
                    script/dx/server-start --ui
                fi
            else
                echo "Error: script/dx/server-start not found" >&2
                exit 1
            fi
            ;;
        sweagentd)
            local socket="/tmp/overmind-sweagentd.sock"
            if [[ -S "$socket" ]]; then
                echo "Overmind is already running for sweagentd."
                echo "Use 'cs-services logs sweagentd' to view logs."
                echo "Use 'cs-services stop sweagentd' first if you want to restart."
                exit 0
            fi
            if [[ -x "script/server" ]]; then
                if [[ "$background" == "true" ]]; then
                    OVERMIND_DAEMONIZE=1 script/server >/dev/null 2>&1 &
                else
                    OVERMIND_DAEMONIZE=1 script/server
                fi
            else
                echo "Error: script/server not found" >&2
                exit 1
            fi
            ;;
        capi)
            if [[ -x "script/manage-overmind-capi" ]]; then
                script/manage-overmind-capi stop || true
            fi
            if [[ -x "script/server" ]]; then
                if [[ "$background" == "true" ]]; then
                    script/server >/dev/null 2>&1 &
                else
                    script/server
                fi
            else
                echo "Error: script/server not found" >&2
                exit 1
            fi
            ;;
        mission-control)
            if [[ -x "script/server" ]]; then
                if [[ "$background" == "true" ]]; then
                    script/server --type all --background >/dev/null 2>&1 &
                else
                    script/server --type all --background
                fi
            elif [[ -f "Makefile" ]] && grep -q "^run:" Makefile 2>/dev/null; then
                if [[ "$background" == "true" ]]; then
                    make run >/dev/null 2>&1 &
                else
                    make run
                fi
            else
                echo "Error: No start script found" >&2
                exit 1
            fi
            ;;
    esac

    echo "$service started."
    set_state_dir "$service" "$dir"
}

# Stop a service (or all services if "all" specified)
cmd_stop() {
    local service="$1"
    
    # If "all" specified, stop all services
    if [[ "$service" == "all" ]]; then
        echo "Stopping all services..."
        for svc in sweagentd capi mission-control github; do
            if service_exists "$svc" && [[ "$(get_service_status "$svc")" == "UP" ]]; then
                cmd_stop "$svc"
            fi
        done
        echo "All services stopped."
        return 0
    fi
    
    shift
    local worktree=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --worktree)
                worktree="${2:-}"
                shift 2
                ;;
            --worktree=*)
                worktree="${1#--worktree=}"
                shift
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
        esac
    done
    validate_service "$service"

    read_state
    local dir
    dir=$(resolve_service_dir "$service" "$worktree" "state")

    echo "Stopping $service..."

    case "$service" in
        github)
            cd "$dir"
            if [[ -x "script/dx/server-stop" ]]; then
                script/dx/server-stop
            else
                echo "Error: script/dx/server-stop not found" >&2
                exit 1
            fi
            ;;
        sweagentd)
            local socket="/tmp/overmind-sweagentd.sock"
            if [[ -S "$socket" ]]; then
                overmind quit -s "$socket" 2>/dev/null || true
            else
                echo "No running process found for sweagentd"
            fi
            ;;
        capi)
            cd "$dir"
            if [[ -x "script/manage-overmind-capi" ]]; then
                script/manage-overmind-capi stop
            elif [[ -f "tmp/pids/server.pid" ]]; then
                local pid
                pid=$(cat "tmp/pids/server.pid")
                kill "$pid" 2>/dev/null || true
            else
                echo "No running process found for capi"
            fi
            ;;
        mission-control)
            cd "$dir"
            if [[ -x "script/stop" ]]; then
                script/stop --type all
            elif [[ -f "tmp/pids/server.pid" ]]; then
                local pid
                pid=$(cat "tmp/pids/server.pid")
                kill "$pid" 2>/dev/null || true
            else
                echo "No running process found for mission-control"
            fi
            ;;
    esac

    echo "$service stopped."
}

# Restart a service
cmd_restart() {
    local service="$1"
    shift
    local worktree=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --worktree)
                worktree="${2:-}"
                shift 2
                ;;
            --worktree=*)
                worktree="${1#--worktree=}"
                shift
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
        esac
    done
    validate_service "$service"

    if [[ -n "$worktree" ]]; then
        cmd_stop "$service" --worktree "$worktree"
        sleep 2
        cmd_start "$service" --worktree "$worktree"
        return
    fi

    cmd_stop "$service"
    sleep 2
    cmd_start "$service"
}

# Tail logs for a service
cmd_logs() {
    local service="$1"
    shift
    local worktree=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --worktree)
                worktree="${2:-}"
                shift 2
                ;;
            --worktree=*)
                worktree="${1#--worktree=}"
                shift
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                exit 1
                ;;
        esac
    done
    validate_service "$service"

    read_state
    local dir
    dir=$(resolve_service_dir "$service" "$worktree" "state")

    case "$service" in
        github)
            cd "$dir"
            if [[ -x "script/dx/server-logs" ]]; then
                exec script/dx/server-logs
            elif command -v overmind &>/dev/null; then
                exec overmind echo
            else
                echo "Error: No log viewer available" >&2
                exit 1
            fi
            ;;
        sweagentd)
            local socket="/tmp/overmind-sweagentd.sock"
            if [[ -S "$socket" ]]; then
                exec overmind echo -s "$socket"
            else
                echo "Error: Overmind socket not found at $socket" >&2
                echo "Is sweagentd running?" >&2
                exit 1
            fi
            ;;
        capi)
            cd "$dir"
            if [[ -d "log" ]]; then
                exec tail -f log/*.log
            elif [[ -f ".env" ]]; then
                echo "No log directory found. Service may log to stdout." >&2
                exit 1
            fi
            ;;
        mission-control)
            cd "$dir"
            if [[ -d "log" ]]; then
                exec tail -f log/*.log
            else
                echo "No log directory found. Service may log to stdout." >&2
                exit 1
            fi
            ;;
    esac
}

# Main
if [[ $# -eq 0 ]]; then
    show_help
    exit 0
fi

case "${1:-}" in
    -h|--help)
        show_help
        exit 0
        ;;
    status)
        cmd_status
        ;;
    start)
        shift
        if [[ -z "${1:-}" ]]; then
            echo "Error: Service name required" >&2
            echo "Usage: cs-services start <service>" >&2
            exit 1
        fi
        cmd_start "$@"
        ;;
    stop)
        shift
        if [[ -z "${1:-}" ]]; then
            echo "Error: Service name required" >&2
            echo "Usage: cs-services stop <service|all>" >&2
            exit 1
        fi
        cmd_stop "$@"
        ;;
    restart)
        shift
        if [[ -z "${1:-}" ]]; then
            echo "Error: Service name required" >&2
            echo "Usage: cs-services restart <service>" >&2
            exit 1
        fi
        cmd_restart "$@"
        ;;
    logs)
        shift
        if [[ -z "${1:-}" ]]; then
            echo "Error: Service name required" >&2
            echo "Usage: cs-services logs <service>" >&2
            exit 1
        fi
        cmd_logs "$@"
        ;;
    *)
        echo "Error: Unknown command '${1:-}'" >&2
        echo "Run 'cs-services --help' for usage" >&2
        exit 1
        ;;
esac
