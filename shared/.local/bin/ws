#!/usr/bin/env bash
set -euo pipefail

# ws - Git worktree manager with tmux integration
# Repo-agnostic: detects org/repo from git remote origin
# Worktrees stored in ~/.worktrees/{org}/{repo}/{name}

WORKTREE_BASE="$HOME/.worktrees"

show_help() {
    cat << 'EOF'
ws - Git worktree manager with tmux integration

Usage: ws <command> [options]

Commands:
  new <name>              Create worktree branching off default branch
  new --pr <url>          Create worktree from a GitHub PR URL
  list                    List worktrees for current repo
  list --all              List worktrees across all repos
  open <name>             Open worktree in a tmux session (nvim + copilot)
  delete <name>           Remove worktree and kill its tmux session
  clean                   Remove all worktrees for current repo

Run from inside any git repository. Org and repo are detected from the
origin remote URL.

Worktree paths:  ~/.worktrees/{org}/{repo}/{name}/
Tmux sessions:   {repo}#{branch-name}

Options:
  -h, --help    Show this help message

Examples:
  ws new fix-login            # new worktree + tmux session
  ws new --pr https://github.com/org/repo/pull/1234
  ws list --all                # show worktrees across all repos
  ws open fix-login           # switch to worktree's tmux session
  ws delete fix-login         # remove worktree + session
  ws clean                    # remove all worktrees for this repo
EOF
}

# --- helpers ----------------------------------------------------------------

log() { echo "==> $*"; }
error() { echo "Error: $*" >&2; }

# Detect org and repo from git remote origin
detect_repo_info() {
    local url
    url=$(git remote get-url origin 2>/dev/null) || {
        error "Not in a git repository or no 'origin' remote"
        exit 1
    }

    # Strip trailing .git if present
    url="${url%.git}"

    # SSH: git@github.com:org/repo
    if [[ "$url" =~ ^git@[^:]+:([^/]+)/([^/]+)$ ]]; then
        REPO_ORG="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
    # HTTPS: https://github.com/org/repo
    elif [[ "$url" =~ ^https://[^/]+/([^/]+)/([^/]+)$ ]]; then
        REPO_ORG="${BASH_REMATCH[1]}"
        REPO_NAME="${BASH_REMATCH[2]}"
    else
        error "Cannot parse origin URL: $url"
        exit 1
    fi

    REPO_DIR=$(git rev-parse --show-toplevel)
    REPO_WT_DIR="${WORKTREE_BASE}/${REPO_ORG}/${REPO_NAME}"
}

get_default_branch() {
    git -C "$REPO_DIR" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null \
        | sed 's@^refs/remotes/origin/@@' || echo "main"
}

worktree_path() {
    echo "${REPO_WT_DIR}/$1"
}

worktree_exists() {
    [[ -d "$(worktree_path "$1")" ]]
}

# Sanitize a string for use as tmux session name (no dots/colons)
tmux_session_name() {
    local name="$1"
    echo "${REPO_NAME}#${name}" | tr './:' '_-_'
}

# Create or switch to a tmux session for a worktree
tmux_open() {
    local name="$1"
    local wt_path
    wt_path=$(worktree_path "$name")
    local session
    session=$(tmux_session_name "$name")

    if tmux has-session -t="$session" 2>/dev/null; then
        log "Tmux session '$session' already exists, switching..."
    else
        log "Creating tmux session '$session'..."

        # Create session (hook may rename it, so we capture the id)
        local sid
        sid=$(tmux new-session -d -P -F '#{session_id}' -c "$wt_path" -n "$REPO_NAME")

        # Rename to our desired name (overrides the after-new-session hook)
        tmux rename-session -t "$sid" "$session"

        tmux set-option -t "$sid" automatic-rename off
        tmux send-keys -t "$sid" "nvim" C-m

        # Window 2: copilot
        tmux new-window -t "$sid" -c "$wt_path" -n "copilot"
        tmux send-keys -t "${sid}:copilot" "copilot --yolo" C-m

        # Focus nvim window
        tmux select-window -t "${sid}:1"
    fi

    if [[ -z "${TMUX:-}" ]]; then
        tmux attach-session -t "$session"
    else
        tmux switch-client -t "$session"
    fi
}

# --- commands ---------------------------------------------------------------

cmd_new() {
    local name="" pr_url=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --pr)
                pr_url="$2"
                shift 2
                ;;
            -*)
                error "Unknown option: $1"
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    if [[ -n "$pr_url" ]]; then
        # PR mode: parse org/repo/number from URL
        # e.g. https://github.com/github/copilot-mission-control/pull/1527
        if [[ ! "$pr_url" =~ github\.com/([^/]+)/([^/]+)/pull/([0-9]+) ]]; then
            error "Invalid PR URL: $pr_url"
            echo "Expected format: https://github.com/org/repo/pull/NUMBER" >&2
            exit 1
        fi

        local pr_org="${BASH_REMATCH[1]}"
        local pr_repo="${BASH_REMATCH[2]}"
        local pr_number="${BASH_REMATCH[3]}"

        # Find the local clone of this repo
        REPO_DIR="$HOME/Development/${pr_org}/${pr_repo}"
        if [[ ! -d "$REPO_DIR/.git" ]]; then
            error "Local clone not found at ${REPO_DIR}"
            echo "Clone it first: gh-clone https://github.com/${pr_org}/${pr_repo}" >&2
            exit 1
        fi

        REPO_ORG="$pr_org"
        REPO_NAME="$pr_repo"
        REPO_WT_DIR="${WORKTREE_BASE}/${REPO_ORG}/${REPO_NAME}"

        log "Fetching PR #${pr_number} info..."
        local pr_json
        pr_json=$(gh pr view "$pr_number" \
            --repo "${REPO_ORG}/${REPO_NAME}" \
            --json headRefName,title 2>&1) || {
            error "Failed to fetch PR #${pr_number}: $pr_json"
            exit 1
        }

        local pr_branch pr_title
        pr_branch=$(echo "$pr_json" | jq -r '.headRefName')
        pr_title=$(echo "$pr_json" | jq -r '.title')

        # Use PR number as worktree name if no name given
        [[ -z "$name" ]] && name="pr-${pr_number}"

        log "PR #${pr_number}: ${pr_title}"
        log "Branch: ${pr_branch}"

        local wt_path
        wt_path=$(worktree_path "$name")

        if worktree_exists "$name"; then
            error "Worktree already exists at ${wt_path}"
            exit 1
        fi

        log "Fetching latest from origin..."
        git -C "$REPO_DIR" fetch origin --quiet

        log "Creating worktree at ${wt_path}..."
        mkdir -p "$REPO_WT_DIR"
        git -C "$REPO_DIR" worktree add "$wt_path" "$pr_branch"
    else
        # Normal mode: create new branch from default branch
        if [[ -z "$name" ]]; then
            error "Usage: ws new <name>  or  ws new --pr <url>"
            exit 1
        fi

        detect_repo_info

        local wt_path
        wt_path=$(worktree_path "$name")
        local branch="$name"

        if worktree_exists "$name"; then
            error "Worktree already exists at ${wt_path}"
            exit 1
        fi

        log "Fetching latest from origin..."
        git -C "$REPO_DIR" fetch origin --quiet

        local default_branch
        default_branch=$(get_default_branch)

        log "Creating branch '$branch' from origin/${default_branch}..."
        mkdir -p "$REPO_WT_DIR"
        git -C "$REPO_DIR" worktree add -b "$branch" "$wt_path" "origin/${default_branch}"
    fi

    echo
    echo "✓ Worktree created!"
    echo
    echo "  Repo:   ${REPO_ORG}/${REPO_NAME}"
    echo "  Name:   $name"
    echo "  Path:   $(worktree_path "$name")"
    echo

    # Auto-open tmux session
    tmux_open "$name"
}

cmd_list() {
    local show_all=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all) show_all=true; shift ;;
            *) error "Unknown option: $1"; exit 1 ;;
        esac
    done

    if $show_all; then
        cmd_list_all
        return
    fi

    detect_repo_info

    if [[ ! -d "$REPO_WT_DIR" ]]; then
        echo "No worktrees for ${REPO_ORG}/${REPO_NAME}."
        return 0
    fi

    local found=false

    printf "%-20s %-30s %-40s %-10s\n" "NAME" "BRANCH" "PATH" "TMUX"
    printf "%-20s %-30s %-40s %-10s\n" "----" "------" "----" "----"

    while IFS= read -r line; do
        local wt_path wt_branch
        wt_path=$(echo "$line" | awk '{print $1}')
        wt_branch=$(echo "$line" | grep -o '\[.*\]' | tr -d '[]' || echo "?")

        # Skip main worktree
        [[ "$wt_path" == "$REPO_DIR" ]] && continue
        # Skip worktrees not in our managed directory
        [[ "$wt_path" != "${REPO_WT_DIR}/"* ]] && continue

        local wt_name
        wt_name=$(basename "$wt_path")
        local session
        session=$(tmux_session_name "$wt_name")

        local tmux_status="no"
        tmux has-session -t="$session" 2>/dev/null && tmux_status="yes"

        printf "%-20s %-30s %-40s %-10s\n" "$wt_name" "$wt_branch" "$wt_path" "$tmux_status"
        found=true
    done < <(git -C "$REPO_DIR" worktree list 2>/dev/null || true)

    if ! $found; then
        echo "No worktrees for ${REPO_ORG}/${REPO_NAME}."
    fi
}

cmd_list_all() {
    if [[ ! -d "$WORKTREE_BASE" ]]; then
        echo "No worktrees found."
        return 0
    fi

    local found=false

    printf "%-25s %-20s %-30s %-10s\n" "REPO" "NAME" "BRANCH" "TMUX"
    printf "%-25s %-20s %-30s %-10s\n" "----" "----" "------" "----"

    # Walk ~/.worktrees/{org}/{repo}/{name}
    for org_dir in "$WORKTREE_BASE"/*/; do
        [[ -d "$org_dir" ]] || continue
        local org
        org=$(basename "$org_dir")

        for repo_dir in "$org_dir"*/; do
            [[ -d "$repo_dir" ]] || continue
            local repo
            repo=$(basename "$repo_dir")

            # Find the main clone to query git worktree list
            local main_clone="$HOME/Development/${org}/${repo}"
            if [[ ! -d "$main_clone/.git" ]]; then
                # Fallback: list directories directly
                for wt_dir in "$repo_dir"*/; do
                    [[ -d "$wt_dir" ]] || continue
                    local wt_name
                    wt_name=$(basename "$wt_dir")
                    printf "%-25s %-20s %-30s %-10s\n" "${org}/${repo}" "$wt_name" "?" "?"
                    found=true
                done
                continue
            fi

            while IFS= read -r line; do
                local wt_path wt_branch
                wt_path=$(echo "$line" | awk '{print $1}')
                wt_branch=$(echo "$line" | grep -o '\[.*\]' | tr -d '[]' || echo "?")

                [[ "$wt_path" == "$main_clone" ]] && continue
                [[ "$wt_path" != "${repo_dir}"* ]] && continue

                local wt_name
                wt_name=$(basename "$wt_path")

                # Check tmux session
                local session="${repo}#${wt_name}"
                session=$(echo "$session" | tr './:' '_-_')
                local tmux_status="no"
                tmux has-session -t="$session" 2>/dev/null && tmux_status="yes"

                printf "%-25s %-20s %-30s %-10s\n" "${org}/${repo}" "$wt_name" "$wt_branch" "$tmux_status"
                found=true
            done < <(git -C "$main_clone" worktree list 2>/dev/null || true)
        done
    done

    if ! $found; then
        echo "No worktrees found."
    fi
}

cmd_open() {
    if [[ $# -lt 1 ]]; then
        error "Usage: ws open <name>"
        exit 1
    fi

    local name="$1"
    detect_repo_info

    if ! worktree_exists "$name"; then
        error "Worktree '$name' not found in ${REPO_WT_DIR}/"
        echo "Run 'ws list' to see available worktrees." >&2
        exit 1
    fi

    tmux_open "$name"
}

cmd_delete() {
    if [[ $# -lt 1 ]]; then
        error "Usage: ws delete <name>"
        exit 1
    fi

    local name="$1"

    # Find the worktree across all repos in ~/.worktrees/{org}/{repo}/{name}
    local wt_path="" found_org="" found_repo="" main_clone=""
    for org_dir in "$WORKTREE_BASE"/*/; do
        [[ -d "$org_dir" ]] || continue
        for repo_dir in "$org_dir"*/; do
            [[ -d "$repo_dir" ]] || continue
            if [[ -d "${repo_dir}${name}" ]]; then
                wt_path="${repo_dir}${name}"
                found_org=$(basename "$org_dir")
                found_repo=$(basename "$repo_dir")
                main_clone="$HOME/Development/${found_org}/${found_repo}"
                break 2
            fi
        done
    done

    if [[ -z "$wt_path" ]]; then
        error "Worktree '$name' not found in ${WORKTREE_BASE}/"
        exit 1
    fi

    # Kill tmux session if it exists
    local session
    session=$(echo "${found_repo}#${name}" | tr './:' '_-_')
    if tmux has-session -t="$session" 2>/dev/null; then
        log "Killing tmux session '$session'..."
        tmux kill-session -t "$session"
    fi

    # Get the branch name before removing
    local branch
    branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

    # Remove via git worktree if main clone exists, otherwise just delete the dir
    if [[ -d "$main_clone/.git" ]]; then
        log "Removing worktree..."
        git -C "$main_clone" worktree remove "$wt_path" --force

        # Delete local branch if it exists
        if [[ -n "$branch" && "$branch" != "HEAD" ]]; then
            if git -C "$main_clone" show-ref --verify --quiet "refs/heads/${branch}" 2>/dev/null; then
                log "Deleting local branch '$branch'..."
                git -C "$main_clone" branch -D "$branch" 2>/dev/null || true
            fi
        fi
    else
        # Only remove if path is safely under WORKTREE_BASE
        if [[ "$wt_path" != "${WORKTREE_BASE}/"* ]]; then
            error "Refusing to remove path outside of ${WORKTREE_BASE}: $wt_path"
            exit 1
        fi
        log "Main clone not found at $main_clone, removing directory..."
        rm -rf "$wt_path"
    fi

    # Clean up empty parent dirs
    rmdir "${WORKTREE_BASE}/${found_org}/${found_repo}" 2>/dev/null || true
    rmdir "${WORKTREE_BASE}/${found_org}" 2>/dev/null || true

    echo
    echo "✓ Worktree '$name' deleted (${found_org}/${found_repo})."
}

cmd_clean() {
    detect_repo_info

    if [[ ! -d "$REPO_WT_DIR" ]]; then
        echo "No worktrees for ${REPO_ORG}/${REPO_NAME}."
        return 0
    fi

    local names=()
    while IFS= read -r line; do
        local wt_path
        wt_path=$(echo "$line" | awk '{print $1}')
        [[ "$wt_path" == "$REPO_DIR" ]] && continue
        [[ "$wt_path" != "${REPO_WT_DIR}/"* ]] && continue
        names+=("$(basename "$wt_path")")
    done < <(git -C "$REPO_DIR" worktree list 2>/dev/null || true)

    if [[ ${#names[@]} -eq 0 ]]; then
        echo "No worktrees to clean."
        return 0
    fi

    echo "Will delete ${#names[@]} worktree(s) for ${REPO_ORG}/${REPO_NAME}:"
    printf "  %s\n" "${names[@]}"
    echo

    read -rp "Continue? [y/N] " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Aborted."
        return 0
    fi

    for name in "${names[@]}"; do
        cmd_delete "$name"
    done

    # Clean up empty directory
    rmdir "$REPO_WT_DIR" 2>/dev/null || true
    rmdir "${WORKTREE_BASE}/${REPO_ORG}" 2>/dev/null || true

    echo
    echo "✓ All worktrees cleaned."
}

# --- main -------------------------------------------------------------------

if [[ $# -eq 0 ]]; then
    show_help
    exit 0
fi

case "${1:-}" in
    -h|--help)
        show_help
        exit 0
        ;;
    new)    shift; cmd_new "$@" ;;
    list)   shift; cmd_list "$@" ;;
    open)   shift; cmd_open "$@" ;;
    delete) shift; cmd_delete "$@" ;;
    clean)  shift; cmd_clean "$@" ;;
    *)
        error "Unknown command '${1:-}'"
        echo "Run 'ws --help' for usage" >&2
        exit 1
        ;;
esac
